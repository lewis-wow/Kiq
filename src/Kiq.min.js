//LudvÃ­k Prokopec, MIT
(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.Kiq=b())})(this,function(){"use strict";function a(a){return Array.isArray(a)}function b(a){return!!(c(a)&&a.prototype.isKiqComponent)}function c(a){return"function"==typeof a}function d(a){return null===a||void 0===a}function e(a){return"object"==typeof a&&null!==a}function f(a,c=null,...d){c=c||{};let e=null,f=null;return"_key"in c&&(e=c._key.toString()),"_ref"in c&&(f=c._ref),(d.length||!b(a))&&(c={children:d,...c}),{__t:a,props:c,_key:e,_ref:f}}function g(a,b){let d;if(e(b))d=b;else if(c(b))d=b.bind(a)(a.props,a.state);else throw TypeError(`setState(...) expecting 1 parameter as Function or Object, you give ${typeof b}`);if(Object.keys(d).length){const b=p(a,null,d);return o(b,(b,c)=>{const d=a.__i,e=b(d.__r);Object.assign(d,{__v:e.__v,__r:e.__r}),a.onComponentUpdate(c)},null),a}throw Error(`setState(...) must be Object or Function that returns Object, if Object is empty or doesn't return nothing, update can be redundant`)}function h(a){const b=new a.__t(a.props);return b.__i.__v=b.Element(b.props,b.state),b.__t=a.__t,b}function i(a){return this.props=a,this.state={},this.__i={__r:null,__v:null},this}function j(a,b,c){return e(b)&&Object.assign(a.props,b),e(c)&&Object.assign(a.state,c),a}function k(a){return a.getSnapshotBeforeUpdate()||null}function l(a,b){return a.componentWillGetProps(b)||null}function m(c){if(e(c))if(b(c.__t))n(c),m(c.__i.__v);else{const b=a(c)?c:c.props.children;for(let a=0;a<b.length;a++)m(b[a].__v)}}function n(a){a.onComponentWillUnMount(a.__i.__r),a.setState=function(){a.setState=function(){};const b=a.constructor.name;throw Error(`Remove all asynchronnous functions that causes setState(...) of ${b} in onComponentWillUnMount, else it causes memory leak`)}}function o(a,b,c){if(!a)return c;const[d,e]=a;return d?b(d,e):c}function p(a,b,c){if(!a.shouldComponentUpdate(b,c))return a=j(a,b,c),a.onComponentCancelUpdate(),!1;const d=k(a);j(a,b,c),a.onComponentWillUpdate(d);const e=a.Element(a.props,a.state);return[x(a.__i.__v,e),d]}function q(c){if(d(c))throw Error(`virtual node cannot be null or undefined`);if(!e(c))return{__r:document.createTextNode(c),__v:c};if(a(c)){const a=[];for(let b=0;b<c.length;b++)a.push(q(c[b]));return a}if(b(c.__t)){const a=h(c),b=a.__i,d=q(b.__v);return Object.assign(b,d),a.onComponentRender(d.__r),a.setState=b=>g(a,b),{__v:a,__r:d.__r,_key:c._key}}const f=s(c);return f._ref&&f._ref(f.__r),f}function r(a,c,d){const f=a.__v;if(e(f)&&b(f.__t)){const a=f.__i;f.onComponentWillMount(a.__r,c),d(),f.onComponentMount(a.__r,c)}else d()}function s(b){const c=document.createElement(b.__t),d=b.props,f={};Object.keys(d).filter(w).forEach(a=>(f[a]=d[a],v(a)?c.addEventListener(u(a),d[a]):e(d[a])?Object.assign(c[a],d[a]):c[a]=d[a]));const g=d.children,h=[];if(g)for(let b=0;b<g.length;b++){const d=q(g[b]);a(d)?t(d,c):r(d,c,()=>{c.appendChild(d.__r)}),h.push(d)}const i=b._key;return{__v:{__t:b.__t,props:{children:h,...f}},__r:c,_key:i,_ref:b._ref}}function t(a,b){for(let c=0;c<a.length;c++){const d=a[c];r(d,b,()=>{b.appendChild(d.__r)})}}function u(a){return a.replace("on","")}function v(a){return a.startsWith("on")}function w(a){return"children"!==a}function x(a,c){if(void 0===c)return function(b){return m(a.__v),void b.remove()};const d=e(a),f=e(c);if(!d||!f)return A(a,c,d,f);const g=b(a.__t),h=b(c.__t);if(g||h)return y(a,c,g,h);if(a.__t!==c.__t)return function(a){const b=q(c);return r(b,a.parentNode,()=>{a.replaceWith(b.__r)}),b};const i=B(a.props,c.props);return i?function(b){return a.props=i(b),{__v:a,__r:b,_key:c._key}}:null}function y(a,b,c,d){if(c&&d){if(a.__t===b.__t){const c=l(a,b.props),d=p(a,b.props,c);return o(d,(c,d)=>function(e){const f=c(e);return Object.assign(a.__i,{__v:f.__v,__r:f.__r}),a.onComponentUpdate(d),{__v:a,__r:e,_key:b._key}},null)}const c=h(b),d=c.__i,e=a.__i,f=x(e.__v,c.__i.__v);return n(a),function(a){c.onComponentWillMount(a,a.parentNode);const g=f?f(a):e;Object.assign(d,{__v:g.__v,__r:g.__r});const h=d.__r;return c.onComponentMount(h,h.parentNode),{__v:c,__r:h,_key:b._key}}}if(c&&!d){const c=a.__i,d=x(c.__v,b);return n(a),d?a=>d(a):a=>({__v:c.__v,__r:a,_key:b._key})}const e=h(b),f=e.__i,g=x(a,f.__v);return function(c){e.onComponentWillMount(c,c.parentNode);const d=g?g(c):{__v:a,__r:c};Object.assign(f,{__v:d.__v,__r:d.__r});const h=f.__r;return e.onComponentMount(h,h.parentNode),{__v:e,__r:h,_key:b._key}}}function z(b,c){const d=[],e=[],f=[],[g,h]=C(b),[i,j]=C(c),k=Math.max(j.length,h.length);for(let g=0;g<k;g++){const h=b[g];if(a(h)){const a=z(h,c[g]);a?f.push(function(b){d[g]=a(b)}):d[g]=h}else if(void 0===h){const a=q(c[g]);d[g]=a,f.push(function(b){r(a,b,()=>{b.appendChild(a.__r)})})}else{const a=x(h.__v,c[g]);a?(h.patch=function(b){const c=a(b);void 0!==c&&(d[g]=c)},e.push(g)):d[g]=h}}for(const a in g){const f=g[a],h=i[a],j=b[f],k=x(j.__v,c[h]);k?(j.patch=function(a){const b=k(a);void 0!==b&&(d[h]=b)},e.push(f)):d[h]=j,delete i[a]}for(const a in i){const b=i[a],e=q(c[b]);d[b]=e,f.push(function(a){r(e,a,()=>{a.insertBefore(e.__r,a.childNodes[b])})})}return 0===f.length+e.length?null:function(a){for(let c=0;c<e.length;c++){const a=b[e[c]];a.patch(a.__r)}for(let b=0;b<f.length;b++)f[b](a);return d}}function A(a,b,c,d){return c||d?function(a){const c=q(b);return r(c,a.parentNode,()=>{a.replaceWith(c.__r)}),c}:a===b?null:function(a){return a.nodeValue=b,{__v:b,__r:a}}}function B(a,b){const c=[],d={};if(Object.keys(b).filter(w).forEach(f=>{let g=!1;v(f)?!(f in a)&&(c.push(function(a){a.addEventListener(u(f),b[f])}),g=!0):e(b[f])?(c.push(function(a){Object.assign(a[f],b[f])}),g=!0):(b[f]!==a[f]||!(f in a))&&(c.push(function(a){a[f]=b[f]}),g=!0),d[f]=g?b[f]:a[f]}),0===a.children.length+b.children.length)d.children=a.children;else{const e=z(a.children,b.children);e?c.push(function(a){d.children=e(a)}):d.children=a.children}return Object.keys(a).filter(w).forEach(d=>{d in b||(v(d)?c.push(function(b){b.removeEventListener(u(d),a[d])}):c.push(function(a){a[d]=null,a.removeAttribute(d)}))}),c.length?function(a){for(let b=0;b<c.length;b++)c[b](a);return d}:null}function C(a){const b={},c=[];for(let d=0;d<a.length;d++){const e=a[d],f=e._key;f?!(f in b)&&(b[f]=d):c.push(d)}return[b,c]}return i.prototype.Element=function(){throw Error(`You have to specify Element method in your Component, Element must return virtual element`)},i.prototype.setState=function(){throw Error(`setState(...) can be called only if component is rendered, will be mounted or is mounted`)},i.prototype.onComponentRender=i.prototype.onComponentWillUpdate=i.prototype.onComponentUpdate=i.prototype.onComponentWillMount=i.prototype.onComponentMount=i.prototype.onComponentCancelUpdate=i.prototype.getSnapshotBeforeUpdate=i.prototype.componentWillGetProps=i.prototype.onComponentWillUnMount=function(){},i.prototype.shouldComponentUpdate=function(){return!0},i.prototype.isKiqComponent=!0,{Component:i,render:function(a,b,c){window.requestAnimationFrame(()=>{if(!b||b.nodeType!==Node.ELEMENT_NODE)throw TypeError(`render(...) container must be valid Element that is already rendered on page, try to use DOMContentLoaded event on window to wait for all Elements load`);const d=q(a);r(d.__v,b,()=>{b.appendChild(d.__r)}),c&&c()})},createElement:f}});