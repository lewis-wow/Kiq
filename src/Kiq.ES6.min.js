// LudvÃ­k Prokopec MIT
(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.Kiq=b())})(this,function(){"use strict";function a(a){return Array.isArray(a)}function b(a){return!!(c(a)&&a.prototype.isKiqComponent)}function c(a){return"function"==typeof a}function d(a){return null===a||void 0===a}function e(a){return"object"==typeof a&&null!==a}function f(a,c=null,...d){c=c||{};let e=null,f=null;return"_key"in c&&(e=c._key.toString()),"_ref"in c&&(f=c._ref),(d.length||!b(a))&&(c={children:d,...c}),{type:a,props:c,_key:e,_ref:f}}function g(a,b,c){return e(b)&&Object.assign(a.props,b),e(c)&&Object.assign(a.state,c),a}function h(a){return this.props=a,this.state={},this._internals={realDOM:null,virtualNode:null},this}function i(a){const b=new a.type(a.props);return b._internals.virtualNode=b.Element(b.props,b.state),b.type=a.type,b}function j(a,b){const c=q(a,null,b);return p(c,(b,c)=>{const d=a._internals,e=b(d.realDOM);Object.assign(d,{virtualNode:e.virtualNode,realDOM:e.realDOM}),a.onComponentUpdate(c)},null),a}function k(a,b){let d;if(e(b))d=b;else if(c(b))d=b.bind(a)(a.props,a.state);else throw TypeError(`setState(...) expecting 1 parameter as Function or Object, you give ${typeof b}`);if(Object.keys(d).length)return j(a,d);throw Error(`setState(...) must be Object or Function that returns Object, if Object is empty or doesn't return nothing, update can be redundant`)}function l(a){return a.getSnapshotBeforeUpdate()||null}function m(a,b){return a.componentWillGetProps(b)||null}function n(c){if(e(c))if(b(c.type))o(c),n(c._internals.virtualNode);else{const b=a(c)?c:c.props.children;for(let a=0;a<b.length;a++)n(b[a].virtualNode)}}function o(a){a.onComponentWillUnMount(a._internals.realDOM),a.setState=function(){a.setState=function(){};const b=a.constructor.name;throw Error(`Remove all asynchronnous functions that causes setState(...) of ${b} in onComponentWillUnMount, else it causes memory leak`)}}function p(a,b,c){if(!a)return c;const[d,e]=a;return d?b(d,e):c}function q(a,b,c){if(!a.shouldComponentUpdate(b,c))return a=g(a,b,c),a.onComponentCancelUpdate(),!1;const d=l(a);g(a,b,c),a.onComponentWillUpdate(d);const e=a.Element(a.props,a.state);return[y(a._internals.virtualNode,e),d]}function r(b){const c=document.createElement(b.type),d=b.props,f={};Object.keys(d).filter(x).forEach(a=>(f[a]=d[a],w(a)?c.addEventListener(v(a),d[a]):e(d[a])?Object.assign(c[a],d[a]):c[a]=d[a]));const g=d.children,h=[];if(g)for(let b=0;b<g.length;b++){const d=u(g[b]);a(d)?s(d,c):t(d,c,()=>{c.appendChild(d.realDOM)}),h.push(d)}return{virtualNode:{type:b.type,props:{children:h,...f}},realDOM:c,_key:b._key,_ref:b._ref}}function s(a,b){for(let c=0;c<a.length;c++){const d=a[c];t(d,b,()=>{b.appendChild(d.realDOM)})}}function t(a,c,d){const f=a.virtualNode;if(e(f)&&b(f.type)){const a=f._internals;f.onComponentWillMount(a.realDOM,c),d(),f.onComponentMount(a.realDOM,c)}else d();return a}function u(c){if(d(c))throw Error(`virtual node cannot be null or undefined`);if(!e(c))return{realDOM:document.createTextNode(c),virtualNode:c};if(a(c)){const a=[];for(let b=0;b<c.length;b++)a.push(u(c[b]));return a}if(b(c.type)){const a=i(c),b=a._internals,d=u(b.virtualNode);return Object.assign(b,d),a.onComponentRender(d.realDOM),a.setState=b=>k(a,b),{virtualNode:a,realDOM:d.realDOM,_key:c._key}}const f=r(c);return f._ref&&f._ref(f.realDOM),f}function v(a){return a.replace("on","")}function w(a){return a.startsWith("on")}function x(a){return"children"!==a}function y(a,c){if(void 0===c)return function(b){return n(a.virtualNode),void b.remove()};const d=e(a),f=e(c);if(!d||!f)return B(a,c,d,f);const g=b(a.type),h=b(c.type);if(g||h)return z(a,c,g,h);if(a.type!==c.type)return function(a){const b=u(c);return t(b,a.parentNode,()=>{a.replaceWith(b.realDOM)}),b};const i=C(a.props,c.props);return i?function(b){return a.props=i(b),{virtualNode:a,realDOM:b,_key:c._key}}:null}function z(a,b,c,d){if(c&&d){if(a.type===b.type){const c=m(a,b.props),d=q(a,b.props,c);return p(d,(c,d)=>function(e){const f=c(e);return Object.assign(a._internals,{virtualNode:f.virtualNode,realDOM:f.realDOM}),a.onComponentUpdate(d),{virtualNode:a,realDOM:e,_key:b._key}},null)}const c=i(b),d=c._internals,e=a._internals,f=y(e.virtualNode,c._internals.virtualNode);return o(a),function(a){c.onComponentWillMount(a,a.parentNode);const g=f?f(a):e;Object.assign(d,{virtualNode:g.virtualNode,realDOM:g.realDOM});const h=d.realDOM;return c.onComponentMount(h,h.parentNode),{virtualNode:c,realDOM:h,_key:b._key}}}if(c&&!d){const c=a._internals,d=y(c.virtualNode,b);return o(a),d?a=>d(a):a=>({virtualNode:c.virtualNode,realDOM:a,_key:b._key})}const e=i(b),f=e._internals,g=y(a,f.virtualNode);return function(c){e.onComponentWillMount(c,c.parentNode);const d=g?g(c):{virtualNode:a,realDOM:c};Object.assign(f,{virtualNode:d.virtualNode,realDOM:d.realDOM});const h=f.realDOM;return e.onComponentMount(h,h.parentNode),{virtualNode:e,realDOM:h,_key:b._key}}}function A(b,c){const d=[],e=[],f=[],[g,h]=D(b),[i,j]=D(c),k=Math.max(j.length,h.length);for(let g=0;g<k;g++){const h=b[g];if(a(h)){const a=A(h,c[g]);a?f.push(function(b){d[g]=a(b)}):d[g]=h}else if(void 0===h){const a=u(c[g]);d[g]=a,f.push(function(b){t(a,b,()=>{b.appendChild(a.realDOM)})})}else{const a=y(h.virtualNode,c[g]);a?(h.patch=function(b){const c=a(b);void 0!==c&&(d[g]=c)},e.push(g)):d[g]=h}}for(const a in g){const f=g[a],h=i[a],j=b[f],k=y(j.virtualNode,c[h]);k?(j.patch=function(a){const b=k(a);void 0!==b&&(d[h]=b)},e.push(f)):d[h]=j,delete i[a]}for(const a in i){const b=i[a],e=u(c[b]);d[b]=e,f.push(function(a){t(e,a,()=>{a.insertBefore(e.realDOM,a.childNodes[b])})})}return 0===f.length+e.length?null:function(a){for(let c=0;c<e.length;c++){const a=b[e[c]];a.patch(a.realDOM)}for(let b=0;b<f.length;b++)f[b](a);return d}}function B(a,b,c,d){return c||d?function(a){const c=u(b);return t(c,a.parentNode,()=>{a.replaceWith(c.realDOM)}),c}:a===b?null:function(a){return a.nodeValue=b,{virtualNode:b,realDOM:a}}}function C(a,b){const c=[],d={};if(Object.keys(b).filter(x).forEach(f=>{let g=!1;w(f)?(!(f in a)||a[f]!==b[f])&&(c.push(function(a){a.addEventListener(v(f),b[f])}),g=!0):e(b[f])?(c.push(function(a){Object.assign(a[f],b[f])}),g=!0):(b[f]!==a[f]||!(f in a))&&(c.push(function(a){a[f]=b[f]}),g=!0),d[f]=g?b[f]:a[f]}),0===a.children.length+b.children.length)d.children=a.children;else{const e=A(a.children,b.children);e?c.push(function(a){d.children=e(a)}):d.children=a.children}return Object.keys(a).filter(x).forEach(d=>{d in b&&a[d]===b[d]||(w(d)?c.push(function(b){b.removeEventListener(v(d),a[d])}):c.push(function(a){a[d]=null,a.removeAttribute(d)}))}),c.length?function(a){for(let b=0;b<c.length;b++)c[b](a);return d}:null}function D(a){const b={},c=[];for(let d=0;d<a.length;d++){const e=a[d],f=e._key;f?!(f in b)&&(b[f]=d):c.push(d)}return[b,c]}return h.prototype.Element=function(){throw Error(`You have to specify Element method in your Component, Element must return virtual element`)},h.prototype.setState=function(){throw Error(`setState(...) can be called only if component is rendered, will be mounted or is mounted`)},h.prototype.onComponentRender=h.prototype.onComponentWillUpdate=h.prototype.onComponentUpdate=h.prototype.onComponentWillMount=h.prototype.onComponentMount=h.prototype.onComponentCancelUpdate=h.prototype.getSnapshotBeforeUpdate=h.prototype.componentWillGetProps=h.prototype.onComponentWillUnMount=function(){},h.prototype.shouldComponentUpdate=function(){return!0},h.prototype.isKiqComponent=!0,{Component:h,render:function(a,b,c){window.requestAnimationFrame(()=>{if(!b||b.nodeType!==Node.ELEMENT_NODE)throw TypeError(`render(...) container must be valid Element that is already rendered on page, try to use DOMContentLoaded event on window to wait for all Elements load`);const d=u(a);t(d.virtualNode,b,()=>{b.appendChild(d.realDOM)}),c&&c()})},createElement:f}});